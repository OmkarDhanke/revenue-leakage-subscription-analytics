# Day 2: Identify Data & Relationships

## 1.0 Architectural Strategy
To support high-performance reporting, we are utilizing a relational database structure.
* **Reference Tables:** Tables containing static or descriptive data (Who, What).
* **Transactional Tables:** Tables containing high-volume event data (Events, Transactions, Money).

This structure ensures data integrity and supports complex SQL Joins.

---

## 2.0 Reference Tables (The Context)

### Table 1: customers
* **Description:** The master list of all entities purchasing software.
* **Primary Key:** `customer_id`
* **Foreign Keys:** None

| Column Name | Data Type | Description |
| :--- | :--- | :--- |
| **customer_id** | INT | **[PK]** Unique identifier for every user. |
| customer_name | VARCHAR | Name of the individual or company. |
| email | VARCHAR | Contact email (used for dunning notifications). |
| region | VARCHAR | Geographic location (for regional churn analysis). |

### Table 2: plans
* **Description:** The product catalog defining the "Expected Revenue."
* **Primary Key:** `plan_id`
* **Foreign Keys:** None

| Column Name | Data Type | Description |
| :--- | :--- | :--- |
| **plan_id** | INT | **[PK]** Unique identifier for the pricing tier. |
| plan_name | VARCHAR | E.g., "Basic", "Pro", "Enterprise". |
| monthly_price | DECIMAL | The theoretical price (e.g., 10.00, 50.00). Critical for calculating Revenue Leakage. |

---

## 2.1 Transactional Tables (The Action)

### Table 3: subscriptions
* **Description:** The binding contract linking a Customer to a specific Plan.
* **Primary Key:** `sub_id`
* **Foreign Keys:** `customer_id` (Link to User), `plan_id` (Link to Price)

| Column Name | Data Type | Description |
| :--- | :--- | :--- |
| **sub_id** | INT | **[PK]** Unique contract ID. |
| customer_id | INT | **[FK]** Links to customers. |
| plan_id | INT | **[FK]** Links to plans. |
| start_date | DATE | When the billing cycle began. |
| end_date | DATE | Expiration date (or NULL if ongoing). |
| status | VARCHAR | Current state: 'Active', 'Cancelled', 'Expired'. |

### Table 4: invoices
* **Description:** The **demand** for payment generated by the system.
* **Primary Key:** `invoice_id`
* **Foreign Keys:** `sub_id`

| Column Name | Data Type | Description |
| :--- | :--- | :--- |
| **invoice_id** | INT | **[PK]** Unique bill ID. |
| sub_id | INT | **[FK]** Links to the specific subscription contract. |
| invoice_date | DATE | Date the bill was issued. |
| due_date | DATE | Payment deadline. |
| amount | DECIMAL | The total amount requested. |

### Table 5: payments
* **Description:** The **actual receipt** of money (Cash Flow).
* **Primary Key:** `payment_id`
* **Foreign Keys:** `invoice_id`

| Column Name | Data Type | Description |
| :--- | :--- | :--- |
| **payment_id** | INT | **[PK]** Unique transaction receipt ID. |
| invoice_id | INT | **[FK]** Links to the specific invoice being paid. |
| payment_date | DATE | When the bank processed the transfer. |
| amount_paid | DECIMAL | The actual amount collected. |

---

## 3.0 Entity Relationship Diagram (ERD) Logic

![ERD Diagram](docs/Image/ERD.png)  

The relationship flow follows a strict hierarchy to ensure data integrity:
1.  `customers` **purchase** `subscriptions` (1 : Many).
2.  `subscriptions` **generate monthly** `invoices` (1 : Many).
3.  `invoices` **are settled by** `payments` (1 : 1 or 1 : Many).

---

## 4.0 Logic Verification (The "Mental Walkthrough")
*(Does this structure solve the Day 1 Business Problems?)*

We must validate that this schema supports the queries required for our Risk Assessment.

### Scenario A: The "Ghost Subscriber" (Missing Invoices)
* **Can we solve it?** ✅ Yes.
* **The Logic:** We will query `subscriptions` where `status = 'Active'` and LEFT JOIN to `invoices`.
* **Test:** If the `invoice_id` is **NULL** for the current month, we have found a Ghost.

### Scenario B: The "Zombie Account" (Unpaid)
* **Can we solve it?** ✅ Yes.
* **The Logic:** We will query `invoices` and LEFT JOIN to `payments`.
* **Test:** If `payment_id` is **NULL** (or count is 0) **but** the linked `subscriptions.status` is still **'Active'**, we have found a Zombie.

### Scenario C: The "Leaky Bucket" (Partial Payments)
* **Can we solve it?** ✅ Yes.
* **The Logic:** We will JOIN `invoices` to `payments` and compare columns: `invoices.amount` vs `payments.amount_paid`.
* **Test:** Any variance where `Paid < Invoice` is a Leak.